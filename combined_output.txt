# ==== .\app_config.py ====
"""
File: app_config.py
Layer: Configuration
Component: Global Configuration
Description:
    Defines system-wide constants and data paths.
    Ensures all JSON persistence files and folders exist before use.
"""
from pathlib import Path

# Root and data directory
BASE_DIR = Path(__file__).parent
DATA_DIR = BASE_DIR / "data"
DATA_DIR.mkdir(exist_ok=True)

# JSON data files
CUSTOMERS_FILE = DATA_DIR / "customers.json"
ACCOUNTS_FILE  = DATA_DIR / "accounts.json"
PRODUCTS_FILE  = DATA_DIR / "products.json"
INVENTORY_FILE = DATA_DIR / "inventory.json"
ORDERS_FILE    = DATA_DIR / "orders.json"
INVOICES_FILE  = DATA_DIR / "invoices.json"
PAYMENTS_FILE  = DATA_DIR / "payments.json"
SHIPMENTS_FILE = DATA_DIR / "shipments.json"
CARTS_FILE     = DATA_DIR / "carts.json"
STAFF_FILE     = DATA_DIR / "staff.json"

# Business rules and thresholds
MIN_PASSWORD_LENGTH = 8
MAX_CART_ITEMS      = 50
LOW_STOCK_THRESHOLD = 5


# ==== .\combined_output.txt ====


# ==== .\combine_files.py ====
import os

def collect_files(root_dir, output_file):
    # Supported extensions
    extensions = ['.py', '.json', '.txt']
    # Folders to skip
    skip_folders = {'__pycache__', '.pytest_cache', 'venv', '.git'}

    with open(output_file, 'w', encoding='utf-8') as outfile:
        for foldername, subfolders, filenames in os.walk(root_dir):
            # Modify subfolders in-place to skip unwanted ones
            subfolders[:] = [d for d in subfolders if d not in skip_folders]

            for filename in filenames:
                _, ext = os.path.splitext(filename)
                if ext.lower() in extensions:
                    file_path = os.path.join(foldername, filename)
                    try:
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            content = infile.read()
                    except Exception as e:
                        content = f"Error reading file: {e}"

                    # Write file header and content
                    outfile.write(f"# ==== {file_path} ====\n")
                    outfile.write(content + "\n\n")

    print(f"âœ… All files have been written to {output_file}")


if __name__ == "__main__":
    # Change this to your root folder if needed
    root_directory = "."
    output_filename = "combined_output.txt"
    collect_files(root_directory, output_filename)


# ==== .\main.py ====
"""
===============================================================================
File: main.py
Layer: Presentation (Entry Point)
Description:
    Entry point for the Online Convenience Store System (OCSS).
    Uses Typer to expose user commands for Customers and Staff.
    Routes all commands through CLIController in the Presentation Layer.

    Commands implement the four major scenarios:
    - Browse & Add to Cart (Scenario 1)
    - Checkout & Payment (Scenario 2)
    - Staff Processing Orders (Scenario 3)
    - Reporting (Scenario 4)
===============================================================================
"""

import typer
from rich.console import Console
from presentation.cli_controller import CLIController
from storage.session_manager import SessionManager

# Initialize Typer application
app = typer.Typer(
    name="ocss",
    help="Online Convenience Store System (OCSS) - Your Local Shop",
    add_completion=False
)

# Console and controller instances
console = Console()
controller = CLIController()

# ------------------------- SYSTEM SETUP COMMANDS ---------------------------- #

@app.command()
def init():
    """Initialize the system with sample data."""
    result = controller.initialize_system()
    if result["success"]:
        console.print("[green]System initialized with sample data[/green]")
    else:
        console.print(f"[red]{result['message']}[/red]")


# ---------------------------- AUTH COMMANDS --------------------------------- #

@app.command()
def login(username: str, password: str):
    """Login as a customer or staff member."""
    result = controller.login(username, password)
    color = "green" if result["success"] else "red"
    message = result.get("message", "Login failed")
    console.print(f"[{color}]{message}[/{color}]")

@app.command()
def logout():
    """Logout from current session."""
    result = controller.logout()
    console.print("[green]Logged out successfully[/green]")

@app.command()
def whoami():
    """Show current logged-in user."""
    session = SessionManager.load_session()
    if session:
        console.print(f"[cyan]Logged in as: {session['username']} ({session['user_type']})[/cyan]")
    else:
        console.print("[yellow]Not logged in[/yellow]")


# ---------------------------- CUSTOMER COMMANDS ----------------------------- #

@app.command()
def browse(category: str = typer.Argument(None, help="Filter by product category (e.g., Dairy)")):
    """Browse product catalogue."""
    session = SessionManager.load_session()
    if not session:
        console.print("[red]Please login first.[/red]")
        return

    products = controller.browse_products(category)
    if not products:
        console.print("[yellow]No products found.[/yellow]")
        return
    controller.display_products(products)


@app.command(name="add-to-cart")
def add_to_cart(
    product_id: int = typer.Argument(..., help="Product ID to add"),
    quantity: int = typer.Argument(1, help="Quantity (default: 1)")
):
    """Add item to cart: add-to-cart PRODUCT_ID QUANTITY"""
    result = controller.add_to_cart(product_id, quantity)
    color = "green" if result["success"] else "red"
    console.print(f"[{color}]{result['message']}[/{color}]")

@app.command(name="view-cart")
def view_cart():
    """View the current user's shopping cart."""
    session = SessionManager.load_session()
    if not session:
        console.print("[red]Please login first.[/red]")
        return
    if session.get("user_type") != "customer":
        console.print("[red]Customer access required.[/red]")
        return

    cart_data = controller.view_cart()
    if not cart_data.get("items"):
        console.print("[yellow]Your cart is empty.[/yellow]")
        return
    controller.display_cart(cart_data)


@app.command()
def checkout():
    """Checkout and process payment for the current cart."""
    result = controller.checkout()
    if not result["success"] and result.get("message") != "Cart is empty":
        console.print(f"[red]{result['message']}[/red]")


# --------------------------- INVOICE COMMAND -------------------------------- #

@app.command(name="view-invoice")
def view_invoice(
    order_id: int = typer.Argument(..., help="Order ID to view invoice for")
):
    """View detailed invoice for a specific order."""
    controller.view_invoice(order_id)


# ----------------------------- STAFF COMMANDS ------------------------------- #

@app.command(name="view-orders")
def view_orders():
    """View all pending orders (staff only)."""
    session = SessionManager.load_session()
    if not session:
        console.print("[red]Please login first.[/red]")
        return
    if session.get("user_type") != "staff":
        console.print("[red]Staff access required.[/red]")
        return

    orders = controller.view_pending_orders()
    if not orders:
        console.print("[yellow]No pending orders found.[/yellow]")
        return
    controller.display_orders(orders)


@app.command(name="ship-order")
def ship_order(order_id: int = typer.Argument(..., help="Order ID to ship"),
               tracking_number: str = typer.Argument(..., help="Tracking number")):
    """Mark order as shipped (staff only)."""
    session = SessionManager.load_session()
    if not session:
        console.print("[red]Please login first.[/red]")
        return
    if session.get("user_type") != "staff":
        console.print("[red]Staff access required.[/red]")
        return

    result = controller.ship_order(order_id, tracking_number)
    color = "green" if result["success"] else "red"
    console.print(f"[{color}]{result['message']}[/{color}]")


@app.command(name="generate-report")
def generate_report(period: str = typer.Argument("daily", help="Report period: daily|monthly|all")):
    """Generate sales/inventory reports (staff only)."""
    result = controller.generate_report(period)
    if result:
        controller.display_report(result)

@app.command(name="order-status")
def order_status(order_id: int = typer.Argument(..., help="Order ID to check status")):
    """Check the current status of a specific order."""
    session = SessionManager.load_session()
    if not session:
        console.print("[red]Please login first.[/red]")
        return

    from storage.storage_manager import StorageManager
    storage = StorageManager()
    order = storage.find_by_id("orders", order_id)

    if not order:
        console.print(f"[red]Order with ID {order_id} not found.[/red]")
        return

    raw_status = order.get("status", "UNKNOWN").upper()
    if raw_status == "PAID":
        display_status = "NOT SHIPPED"
    elif raw_status == "SHIPPED":
        display_status = "SHIPPED"
    else:
        display_status = raw_status

    console.print(f"[cyan]Order ID:[/cyan] {order['id']}")
    console.print(f"[cyan]Customer ID:[/cyan] {order['customer_id']}")
    console.print(f"[cyan]Total:[/cyan] ${order['total']:.2f}")
    console.print(f"[cyan]Status:[/cyan] {display_status}")

@app.command(name="update-stock")
def update_stock(product_id: int, new_quantity: int):
    """Update product stock (staff only)."""
    result = controller.update_stock(product_id, new_quantity)
    color = "green" if result["success"] else "red"
    console.print(f"[{color}]{result['message']}[/{color}]")



# ----------------------------- ENTRY POINT ---------------------------------- #

if __name__ == "__main__":
    app()


# ==== .\requirements.txt ====
typer==0.12.3
rich==13.7.0
pydantic==2.5.3
pytest==7.4.3



# ==== .\business\__init__.py ====


# ==== .\business\exceptions\errors.py ====
"""
Custom exceptions for OCSS business logic.
Provides domain-specific error types for better error handling.
"""

class InsufficientStockError(Exception):
    """Raised when trying to reserve more stock than available."""
    pass

class PaymentDeclinedError(Exception):
    """Raised when payment processing fails."""
    pass

class InvalidCredentialsError(Exception):
    """Raised when login credentials are invalid."""
    pass

class CartEmptyError(Exception):
    """Raised when trying to checkout with empty cart."""
    pass


# ==== .\business\exceptions\__init__.py ====


# ==== .\business\models\account.py ====
"""
File: account.py
Layer: Business Logic
Component: Domain Model - Account
Description:
    Represents login credentials and role (customer/staff).
    Provides credential verification and simple persistence helpers.
"""
from typing import Optional, Dict
from storage.storage_manager import StorageManager

class Account:
    def __init__(
        self, 
        id: int, 
        username: str, 
        password: str, 
        user_type: str, 
        customer_id: int | None = None, 
        staff_id: int | None = None
    ):
        # init account details
        self.id = id
        self.username = username
        self.password = password  # plain text for now
        self.user_type = user_type  # 'customer' or 'staff'
        self.customer_id = customer_id
        self.staff_id = staff_id

    # verify password
    def verify(self, password: str) -> bool:
        return self.password == password

    # convert account to dict
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "username": self.username,
            "password": self.password,
            "user_type": self.user_type,
            "customer_id": self.customer_id,
            "staff_id": self.staff_id,
        }

    # create account from dict
    @staticmethod
    def from_dict(data: Dict) -> "Account":
        return Account(
            id=data["id"],
            username=data["username"],
            password=data["password"],
            user_type=data["user_type"],
            customer_id=data.get("customer_id"),
            staff_id=data.get("staff_id"),
        )

    # find account by username
    @staticmethod
    def find_by_username(username: str) -> Optional["Account"]:
        s = StorageManager()
        for row in s.load("accounts"):
            if row["username"] == username:
                return Account.from_dict(row)
        return None

    # add a new account to storage
    @staticmethod
    def add(
        username: str, 
        password: str, 
        user_type: str, 
        customer_id: int | None = None, 
        staff_id: int | None = None
    ) -> "Account":
        s = StorageManager()
        rec = s.add("accounts", {
            "username": username,
            "password": password,
            "user_type": user_type,
            "customer_id": customer_id,
            "staff_id": staff_id,
        })
        return Account.from_dict(rec)


# ==== .\business\models\cart.py ====
"""
File: cart.py
Layer: Business Logic
Component: Domain Model - Cart
Description:
    Represents a customer's shopping cart with line items and totals.
    Persists to carts.json. One active cart per customer.
"""
from typing import Dict, List
from storage.storage_manager import StorageManager
from business.models.product import Product
from business.models.inventory import Inventory

class Cart:
    def __init__(self, id: int, customer_id: int, items: List[Dict]):
        # init cart with id, customer and items list
        self.id = id
        self.customer_id = customer_id
        self.items = items

    # check if cart is empty
    def is_empty(self) -> bool:
        return len(self.items) == 0

    # make snapshot for order creation
    def to_order_snapshot(self) -> Dict:
        return {
            "customer_id": self.customer_id,
            "items": [dict(it) for it in self.items],
            "total": self.total(),
        }

    # reserve inventory for all items
    def reserve_all(self) -> None:
        inv = Inventory.get_instance()
        reserved: List[Dict] = []
        try:
            for it in self.items:
                inv.reserve_stock(it["product_id"], int(it["qty"]))
                reserved.append({"product_id": it["product_id"], "qty": int(it["qty"])})
        except Exception:
            # rollback any reserved stock if failed
            for r in reserved:
                try:
                    inv.release_stock(r["product_id"], r["qty"])
                except Exception:
                    pass
            raise

    # release all reserved inventory
    def release_all(self) -> None:
        inv = Inventory.get_instance()
        for it in self.items:
            inv.release_stock(it["product_id"], int(it["qty"]))

    # clear cart and save
    def clear_and_save(self) -> None:
        self.clear()

    # recalc item subtotals
    def _recalculate(self) -> None:
        for it in self.items:
            it["subtotal"] = float(it["price"]) * int(it["qty"])

    # add new item or update quantity
    def add_item(self, product_id: int, qty: int) -> None:
        if qty <= 0:
            raise ValueError("Quantity must be positive")

        p = Product.find_by_id(product_id)
        if not p:
            raise ValueError("Product not found")

        for it in self.items:
            if it["product_id"] == product_id:
                it["qty"] = int(it["qty"]) + int(qty)
                self._recalculate()
                self._save()
                return

        self.items.append({
            "product_id": p.id,
            "name": p.name,
            "price": float(p.price),
            "qty": int(qty),
            "subtotal": float(p.price) * int(qty),
        })
        self._save()

    # update quantity of a specific item
    def update_quantity(self, product_id: int, qty: int) -> None:
        if qty < 0:
            raise ValueError("Quantity cannot be negative")
        for it in self.items:
            if it["product_id"] == product_id:
                it["qty"] = int(qty)
                if it["qty"] == 0:
                    self.items = [x for x in self.items if x["product_id"] != product_id]
                self._recalculate()
                self._save()
                return
        raise ValueError("Item not in cart")

    # clear all items from cart
    def clear(self) -> None:
        self.items = []
        self._save()

    # calculate total price
    def total(self) -> float:
        return sum(float(it["subtotal"]) for it in self.items)

    # convert cart to dictionary
    def to_dict(self) -> Dict:
        return {"id": self.id, "customer_id": self.customer_id, "items": self.items}

    # save cart to storage
    def _save(self) -> None:
        s = StorageManager()
        carts = s.load("carts")
        found = False
        for c in carts:
            if c["id"] == self.id:
                c.update(self.to_dict())
                found = True
                break
        if not found:
            carts.append(self.to_dict())
        s.save_all("carts", carts)

    # get existing cart or create a new one
    @staticmethod
    def get_or_create_for_customer(customer_id: int) -> "Cart":
        s = StorageManager()
        carts = s.load("carts")
        for c in carts:
            if c["customer_id"] == customer_id:
                return Cart(id=c["id"], customer_id=c["customer_id"], items=c.get("items", []))
        rec = s.add("carts", {"customer_id": customer_id, "items": []})
        return Cart(id=rec["id"], customer_id=customer_id, items=[])


# ==== .\business\models\customer.py ====
from typing import List, Dict, Optional
from storage.storage_manager import StorageManager
from business.models.cart import Cart
from business.models.order import Order
from business.models.invoice import Invoice
from business.models.payment import PaymentFactory
from business.models.inventory import Inventory
from business.exceptions.errors import CartEmptyError, InsufficientStockError

class Customer:
    def __init__(self, id: int, name: str, email: str, address: str):
        # init customer with id, name, email, address
        self.id = id
        self.name = name
        self.email = email
        self.address = address

    # get or create customer's cart
    def get_cart(self) -> Cart:
        return Cart.get_or_create_for_customer(self.id)

    # add product to cart
    def add_to_cart(self, product_id: int, qty: int) -> Dict:
        cart = self.get_cart()
        cart.add_item(product_id, qty)
        return {"success": True, "message": "Cart updated"}

    # clear customer's cart
    def clear_cart(self) -> None:
        self.get_cart().clear()

    # perform checkout flow
    def checkout_via(self, payment_method: str = "card") -> Dict:
        cart = self.get_cart()
        if cart.is_empty():
            raise CartEmptyError("Cannot checkout with empty cart")

        inv = Inventory.get_instance()
        try:
            # reserve stock
            cart.reserve_all()
            
            # create order and invoice
            snap = cart.to_order_snapshot()
            order = Order.create(self.id, snap["items"], snap["total"])
            invoice = Invoice.create(order.id, order.total)

            # process payment
            payment = PaymentFactory.create(payment_method, order.total, order.id)
            payment.process()

            # mark as paid
            invoice.mark_paid()
            order.mark_paid()

            # clear cart after payment
            cart.clear()
            return {
                "success": True,
                "order_id": order.id,
                "invoice_id": invoice.id,
                "total": order.total
            }

        except InsufficientStockError as e:
            # release stock if not enough
            cart.release_all()
            return {"success": False, "message": str(e)}

        except Exception as e:
            # release stock if checkout fails
            cart.release_all()
            return {"success": False, "message": f"Checkout failed: {e}"}

    # convert customer to dict
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "email": self.email,
            "address": self.address,
        }

    # create customer from dict
    @staticmethod
    def from_dict(data: Dict) -> "Customer":
        return Customer(
            id=data["id"],
            name=data["name"],
            email=data["email"],
            address=data["address"],
        )

    # add new customer to storage
    @staticmethod
    def add(name: str, email: str, address: str) -> "Customer":
        s = StorageManager()
        rec = s.add("customers", {"name": name, "email": email, "address": address})
        return Customer.from_dict(rec)

    # find customer by id
    @staticmethod
    def find_by_id(customer_id: int) -> Optional["Customer"]:
        s = StorageManager()
        row = s.find_by_id("customers", customer_id)
        return Customer.from_dict(row) if row else None

    # get customer's past orders
    def order_history(self) -> List[Dict]:
        s = StorageManager()
        return [o for o in s.load("orders") if o.get("customer_id") == self.id]


# ==== .\business\models\inventory.py ====
"""
File: inventory.py
Layer: Business Logic
Component: Domain Model - Inventory (Singleton)
Description:
    Single source of truth for stock. Loads and persists stock levels.
    Provides stock checks, reservation, release, and updates.
"""
from typing import Dict, List
from storage.storage_manager import StorageManager
from business.exceptions.errors import InsufficientStockError

class Inventory:
    _instance = None

    # ensure singleton instance
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    # init inventory storage and cache
    def __init__(self):
        if hasattr(self, '_initialized') and self._initialized:
            return
        self._initialized = True
        self._storage = StorageManager()
        self._stock_cache = {}
        self._load_stock()

    # load stock data from storage
    def _load_stock(self) -> None:
        data = self._storage.load("inventory")
        self._stock_cache = {row["product_id"]: int(row["quantity"]) for row in data}

    # save stock data to storage
    def _save_stock(self) -> None:
        data = [{"product_id": pid, "quantity": qty} for pid, qty in self._stock_cache.items()]
        self._storage.save_all("inventory", data)

    # check available stock for product
    def check_stock(self, product_id: int) -> int:
        return int(self._stock_cache.get(product_id, 0))

    # reserve stock for order
    def reserve_stock(self, product_id: int, qty: int) -> None:
        if qty <= 0:
            raise ValueError("Quantity must be positive")
        current = self.check_stock(product_id)
        if current < qty:
            raise InsufficientStockError(f"Only {current} units available for product {product_id}")
        self._stock_cache[product_id] = current - qty
        self._save_stock()

    # release previously reserved stock
    def release_stock(self, product_id: int, qty: int) -> None:
        if qty <= 0:
            raise ValueError("Quantity must be positive")
        current = self.check_stock(product_id)
        self._stock_cache[product_id] = current + qty
        self._save_stock()

    # set stock quantity directly
    def set_stock(self, product_id: int, new_qty: int) -> None:
        if new_qty < 0:
            raise ValueError("Stock cannot be negative")
        self._stock_cache[product_id] = int(new_qty)
        self._save_stock()

    # reserve a list of items in batch
    def reserve_batch(self, items: List[Dict]) -> None:
        reserved = []
        try:
            for it in items:
                pid, qty = int(it["product_id"]), int(it["qty"])
                self.reserve_stock(pid, qty)
                reserved.append({"product_id": pid, "qty": qty})
        except Exception:
            for r in reserved:
                try:
                    self.release_stock(r["product_id"], r["qty"])
                except Exception:
                    pass
            raise

    # release a list of reserved items
    def release_batch(self, items: List[Dict]) -> None:
        for it in items:
            self.release_stock(int(it["product_id"]), int(it["qty"]))

    # get singleton instance
    @classmethod
    def get_instance(cls) -> "Inventory":
        return cls()


# ==== .\business\models\invoice.py ====
"""
File: invoice.py
Layer: Business Logic
Component: Domain Model - Invoice
Description:
    Billing record for an Order. Tracks payment state and total.
"""
from typing import Dict
from storage.storage_manager import StorageManager

class Invoice:
    def __init__(self, id: int, order_id: int, total: float, paid: bool):
        # init invoice details
        self.id = id
        self.order_id = order_id
        self.total = float(total)
        self.paid = bool(paid)

    # process payment and mark invoice/order as paid
    def pay_via(self, method: str = "card"):
        from business.models.payment import PaymentFactory
        from business.models.order import Order

        payment = PaymentFactory.create(method, self.total, self.order_id)
        payment.process()
        self.mark_paid()

        order = Order.find_by_id(self.order_id)
        if order and order.status != "PAID":
            order.mark_paid()

        return payment

    # convert invoice to dictionary
    def to_dict(self) -> Dict:
        return {"id": self.id, "order_id": self.order_id, "total": self.total, "paid": self.paid}

    # create and save new invoice
    @staticmethod
    def create(order_id: int, total: float) -> "Invoice":
        s = StorageManager()
        rec = s.add("invoices", {"order_id": order_id, "total": float(total), "paid": False})
        return Invoice.from_dict(rec)

    # create invoice object from dict
    @staticmethod
    def from_dict(data: Dict) -> "Invoice":
        return Invoice(id=data["id"], order_id=data["order_id"], total=data["total"], paid=data["paid"])

    # mark invoice as paid and update storage
    def mark_paid(self) -> None:
        self.paid = True
        StorageManager().update("invoices", self.id, {"paid": True})


# ==== .\business\models\order.py ====
"""
File: order.py
Layer: Business Logic
Component: Domain Model - Order
Description:
    Immutable snapshot of a confirmed purchase.
    Persists items, totals, timestamps, and status.
"""
from typing import Dict, List
from datetime import datetime
from storage.storage_manager import StorageManager

class Order:
    def __init__(self, id: int, customer_id: int, items: List[Dict], total: float, status: str, created_at: str):
        # init order details
        self.id = id
        self.customer_id = customer_id
        self.items = items
        self.total = float(total)
        self.status = status  # CREATED, PAID, SHIPPED
        self.created_at = created_at

    # create invoice for this order
    def generate_invoice(self):
        from business.models.invoice import Invoice
        return Invoice.create(self.id, self.total)

    # process payment and mark as paid
    def pay_and_mark(self, payment_method: str = "card"):
        from business.models.payment import PaymentFactory
        payment = PaymentFactory.create(payment_method, self.total, self.id)
        payment.process()
        self.mark_paid()
        return payment

    # create shipment and mark order as shipped
    def ship_with(self, tracking_number: str):
        from business.models.shipment import Shipment
        shipment = Shipment.create(self.id, tracking_number)
        shipment.mark_shipped()
        self.mark_shipped()
        return shipment

    # convert order to dictionary
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "customer_id": self.customer_id,
            "items": self.items,
            "total": self.total,
            "status": self.status,
            "created_at": self.created_at,
        }

    # create and save new order
    @staticmethod
    def create(customer_id: int, items: List[Dict], total: float) -> "Order":
        s = StorageManager()
        rec = s.add("orders", {
            "customer_id": customer_id,
            "items": items,
            "total": float(total),
            "status": "CREATED",
            "created_at": datetime.now().isoformat(),
        })
        return Order.from_dict(rec)

    # find order by id
    @staticmethod
    def find_by_id(order_id: int) -> "Order | None":
        s = StorageManager()
        row = s.find_by_id("orders", order_id)
        return Order.from_dict(row) if row else None

    # create order object from dict
    @staticmethod
    def from_dict(data: Dict) -> "Order":
        return Order(
            id=data["id"],
            customer_id=data["customer_id"],
            items=data.get("items", []),
            total=data["total"],
            status=data["status"],
            created_at=data["created_at"],
        )

    # mark order as paid and update storage
    def mark_paid(self) -> None:
        self.status = "PAID"
        StorageManager().update("orders", self.id, {"status": self.status})

    # mark order as shipped and update storage
    def mark_shipped(self) -> None:
        self.status = "SHIPPED"
        StorageManager().update("orders", self.id, {"status": self.status})

    # get short order summary
    def get_summary(self) -> Dict:
        return {"order_id": self.id, "total": self.total, "status": self.status}


# ==== .\business\models\payment.py ====
"""
File: payment.py
Layer: Business Logic
Component: Domain Model - Payment (Factory Method)
Description:
    Abstract payment with concrete mock types. Factory creates the right type.
    On process(), a record is persisted to payments.json.
"""
from typing import Dict
from storage.storage_manager import StorageManager

class PaymentDeclinedError(Exception):
    # custom exception for declined payments
    pass

class Payment:
    def __init__(self, method: str, amount: float, order_id: int):
        # init payment with method, amount, and order id
        self.method = method
        self.amount = float(amount)
        self.order_id = order_id

    # base process method (to be overridden)
    def process(self) -> str:
        raise NotImplementedError

    # save payment record to storage
    def _persist(self, status: str) -> Dict:
        s = StorageManager()
        return s.add("payments", {
            "order_id": self.order_id,
            "method": self.method,
            "amount": self.amount,
            "status": status
        })

    # return status string based on result
    def _persist_result(self, ok: bool) -> str:
        return "APPROVED" if ok else "DECLINED"

# card payment implementation
class CardPayment(Payment):
    def process(self) -> str:
        status = self._persist_result(True)
        self._persist(status)
        return "Card payment processed"

# wallet payment implementation
class WalletPayment(Payment):
    def process(self) -> str:
        status = self._persist_result(True)
        self._persist(status)
        return "Wallet payment processed"

# payment factory to create proper type
class PaymentFactory:
    @staticmethod
    def create(method: str, amount: float, order_id: int) -> Payment:
        m = method.lower()
        if m == "card":
            return CardPayment("card", amount, order_id)
        if m == "wallet":
            return WalletPayment("wallet", amount, order_id)
        raise ValueError("Unsupported payment method")


# ==== .\business\models\product.py ====
"""
File: product.py
Layer: Business Logic
Component: Domain Model - Product
Description:
    Represents a sellable product with descriptive attributes.
    Provides convenience methods for loading and finding products.
"""
from typing import Dict, List, Optional
from storage.storage_manager import StorageManager
from business.models.inventory import Inventory

class Product:
    def __init__(self, id: int, name: str, description: str, price: float, category: str):
        # init product details
        self.id = id
        self.name = name
        self.description = description
        self.price = float(price)
        self.category = category

    # convert product to dictionary
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "price": self.price,
            "category": self.category,
        }

    # create product object from dictionary
    @staticmethod
    def from_dict(data: dict) -> "Product":
        return Product(
            id=data.get("id"),
            name=data.get("name"),
            description=data.get("description", "No description available"),
            price=data.get("price", 0.0),
            category=data.get("category", "Uncategorized"),
        )

    # reserve stock in inventory
    def reserve_stock(self, qty: int) -> None:
        if qty <= 0:
            raise ValueError("Quantity must be positive")
        inv = Inventory.get_instance()
        inv.reserve_stock(self.id, int(qty))

    # release stock in inventory
    def release_stock(self, qty: int) -> None:
        if qty <= 0:
            raise ValueError("Quantity must be positive")
        inv = Inventory.get_instance()
        inv.release_stock(self.id, int(qty))

    # get all products from storage
    @staticmethod
    def get_all() -> List["Product"]:
        s = StorageManager()
        return [Product.from_dict(p) for p in s.load("products")]

    # find product by id
    @staticmethod
    def find_by_id(product_id: int) -> Optional["Product"]:
        s = StorageManager()
        row = s.find_by_id("products", product_id)
        return Product.from_dict(row) if row else None

    # add new product to storage
    @staticmethod
    def add(name: str, description: str, price: float, category: str) -> "Product":
        s = StorageManager()
        rec = s.add("products", {
            "name": name,
            "description": description,
            "price": float(price),
            "category": category
        })
        return Product.from_dict(rec)
    
    # check if product is in stock
    def is_available(self) -> bool:
        inv = Inventory.get_instance()
        return inv.check_stock(self.id) > 0


# ==== .\business\models\report.py ====
"""
File: report.py
Layer: Business Logic
Component: Domain Model - Report (Strategy)
Description:
    Reporting strategies for daily, monthly, and all-time summaries.
    Aggregates orders/payments to produce simple metrics for CLI output.
"""
from typing import List, Dict
from datetime import datetime
from storage.storage_manager import StorageManager

class ReportStrategy:
    # base strategy interface
    def generate(self) -> List[Dict]:
        raise NotImplementedError

# daily report strategy
class DailyReportStrategy(ReportStrategy):
    def generate(self) -> List[Dict]:
        s = StorageManager()
        orders = s.load("orders")
        today = datetime.now().date().isoformat()
        todays = [o for o in orders if o["created_at"][:10] == today]
        revenue = sum(float(o["total"]) for o in todays)
        return [
            {"metric": "Report Type", "value": "Daily"},
            {"metric": "Orders Today", "value": len(todays)},
            {"metric": "Revenue Today", "value": round(revenue, 2)},
        ]

# monthly report strategy
class MonthlyReportStrategy(ReportStrategy):
    def generate(self) -> List[Dict]:
        s = StorageManager()
        orders = s.load("orders")
        ym = datetime.now().strftime("%Y-%m")
        month_orders = [o for o in orders if o["created_at"][:7] == ym]
        revenue = sum(float(o["total"]) for o in month_orders)
        return [
            {"metric": "Report Type", "value": "Monthly"},
            {"metric": "Orders This Month", "value": len(month_orders)},
            {"metric": "Revenue This Month", "value": round(revenue, 2)},
        ]

# all-time report strategy
class AllTimeReportStrategy(ReportStrategy):
    def generate(self) -> List[Dict]:
        s = StorageManager()
        orders = s.load("orders")
        revenue = sum(float(o["total"]) for o in orders)
        return [
            {"metric": "Report Type", "value": "All-Time"},
            {"metric": "Total Orders", "value": len(orders)},
            {"metric": "Total Revenue", "value": round(revenue, 2)},
        ]

class Report:
    def __init__(self, strategy: ReportStrategy):
        # init report with given strategy
        self.strategy = strategy

    # change current strategy
    def set_strategy(self, strategy: ReportStrategy) -> None:
        self.strategy = strategy

    # generate report using selected strategy
    def generate_report(self) -> List[Dict]:
        return self.strategy.generate()


# ==== .\business\models\shipment.py ====
"""
File: shipment.py
Layer: Business Logic
Component: Domain Model - Shipment
Description:
    Handles physical dispatch of an Order and tracks shipping status.
"""
from typing import Dict, Optional
from datetime import datetime
from storage.storage_manager import StorageManager

class Shipment:
    def __init__(self, id: int, order_id: int, tracking_number: str, status: str, shipped_at: str | None):
        # init shipment details
        self.id = id
        self.order_id = order_id
        self.tracking_number = tracking_number
        self.status = status  # PENDING or SHIPPED
        self.shipped_at = shipped_at

    # convert shipment to dictionary
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "order_id": self.order_id,
            "tracking_number": self.tracking_number,
            "status": self.status,
            "shipped_at": self.shipped_at
        }

    # create and save new shipment
    @staticmethod
    def create(order_id: int, tracking_number: str) -> "Shipment":
        s = StorageManager()
        rec = s.add("shipments", {
            "order_id": order_id,
            "tracking_number": tracking_number,
            "status": "PENDING",
            "shipped_at": None
        })
        return Shipment.from_dict(rec)

    # create shipment object from dict
    @staticmethod
    def from_dict(data: Dict) -> "Shipment":
        return Shipment(
            id=data["id"],
            order_id=data["order_id"],
            tracking_number=data["tracking_number"],
            status=data["status"],
            shipped_at=data.get("shipped_at"),
        )

    # find shipment by order id
    @staticmethod
    def find_by_order(order_id: int) -> Optional["Shipment"]:
        s = StorageManager()
        for sh in s.load("shipments"):
            if sh.get("order_id") == order_id:
                return Shipment.from_dict(sh)
        return None

    # mark shipment as shipped and update storage
    def mark_shipped(self) -> None:
        self.status = "SHIPPED"
        self.shipped_at = datetime.now().isoformat()
        StorageManager().update(
            "shipments", self.id, {"status": self.status, "shipped_at": self.shipped_at}
        )


# ==== .\business\models\staff.py ====
"""
File: staff.py
Layer: Business Logic
Component: Domain Model - Staff
Description:
    Represents staff who manage inventory and shipments.

Refactor notes (non-breaking):
    - Added domain-action helpers Staff can perform directly:
        * list_pending_orders()
        * ship_paid_order(order_id, tracking_number)
    - Existing static API preserved.
"""
from typing import Dict, List
from storage.storage_manager import StorageManager
from business.models.order import Order

class Staff:
    def __init__(self, id: int, username: str, name: str):
        self.id = id
        self.username = username
        self.name = name

    # ---------- New collaboration helpers ----------
    def list_pending_orders(self) -> List[Dict]:
        """List all orders not yet shipped."""
        s = StorageManager()
        return [o for o in s.load("orders") if o.get("status") != "SHIPPED"]

    def ship_paid_order(self, order_id: int, tracking_number: str) -> Dict:
        """Ship an order that has been paid."""
        order = Order.find_by_id(order_id)
        if not order:
            return {"success": False, "message": f"Order {order_id} not found"}
        if order.status != "PAID":
            return {"success": False, "message": "Order not yet paid"}
        shipment = order.ship_with(tracking_number)
        return {
            "success": True,
            "message": f"Order {order_id} shipped with tracking {tracking_number}",
            "shipment_id": shipment.id
        }

    # ---------- Existing API ----------
    def to_dict(self) -> Dict:
        """Serialize staff member to dictionary."""
        return {"id": self.id, "username": self.username, "name": self.name}

    @staticmethod
    def from_dict(data: Dict) -> "Staff":
        """Create Staff object from dictionary."""
        return Staff(id=data["id"], username=data["username"], name=data["name"])

    @staticmethod
    def add(username: str, name: str) -> "Staff":
        """Add a new staff member to storage."""
        s = StorageManager()
        rec = s.add("staff", {"username": username, "name": name})
        return Staff.from_dict(rec)

    @staticmethod
    def list_orders_by_status(status: str) -> List[Dict]:
        """Return list of orders filtered by status."""
        s = StorageManager()
        return [o for o in s.load("orders") if o.get("status") == status]


# ==== .\business\models\__init__.py ====


# ==== .\business\services\auth_service.py ====
"""
File: auth_service.py
Layer: Business Logic
Component: Auth Service
Description:
    Handles user authentication and initial sample data creation.
    Links Account, Customer, and Staff domain objects.
"""
from typing import Optional, Dict
from storage.storage_manager import StorageManager
from storage.session_manager import SessionManager
from business.models.account import Account
from business.models.customer import Customer
from business.models.staff import Staff
from business.models.product import Product
from business.models.inventory import Inventory

class AuthService:
    def __init__(self):
        # init storage and session managers
        self.storage = StorageManager()
        self.session_manager = SessionManager()
        # load existing session if any
        self.current_user = self.session_manager.load_session()

    # authenticate user and start session
    def login(self, username: str, password: str) -> Dict:
        accounts = self.storage.load("accounts")
        for acc in accounts:
            if acc["username"] == username and acc["password"] == password:
                self.current_user = acc
                self.session_manager.save_session(acc)
                return {
                    "success": True,
                    "user": acc,
                    "message": f"Logged in as {acc['user_type']}"
                }
        return {"success": False, "message": "Invalid credentials"}

    # logout and clear session
    def logout(self) -> Dict:
        self.current_user = None
        self.session_manager.clear_session()
        return {"success": True, "message": "Logged out successfully"}

    # get current logged-in user
    def get_current_user(self) -> Optional[Dict]:
        if self.current_user is None:
            self.current_user = self.session_manager.load_session()
        return self.current_user

    # initialize sample data for system
    def initialize_system(self) -> Dict:
        self.session_manager.clear_session()

        # seed sample products if empty
        if not self.storage.load("products"):
            Product.add("Milk 1L", "Fresh milk bottle", 3.5, "Dairy")
            Product.add("Bread Loaf", "Whole grain loaf", 4.2, "Bakery")
            Product.add("Eggs (12)", "Dozen free-range eggs", 6.8, "Dairy")

        # set initial stock levels
        inv = Inventory.get_instance()
        inv.set_stock(1, 50)
        inv.set_stock(2, 25)
        inv.set_stock(3, 30)

        # create sample customer and account
        if not self.storage.load("customers"):
            c = Customer.add("John Doe", "john@example.com", "123 Main St, Melbourne")
            Account.add("customer1", "Password123!", "customer", customer_id=c.id)

        # create sample staff and account
        if not self.storage.load("staff"):
            s = Staff.add("staff1", "Admin User")
            Account.add("staff1", "Admin123!", "staff", staff_id=s.id)

        return {"success": True, "message": "System initialized with sample data"}


# ==== .\business\services\cart_service.py ====
"""
File: cart_service.py
Layer: Business Logic
Component: Cart Service
Description:
    Manages customer's cart lifecycle and product browsing.
    Validates stock via Inventory Singleton.
"""
from typing import Dict, List
from storage.storage_manager import StorageManager
from business.models.product import Product
from business.models.inventory import Inventory
from business.models.cart import Cart

class CartService:
    def __init__(self):
        # init storage and inventory
        self.storage = StorageManager()
        self.inventory = Inventory.get_instance()

    # list products with stock info
    def browse_products(self, category: str | None = None) -> List[Dict]:
        products = Product.get_all()
        results = []
        for p in products:
            stock = self.inventory.check_stock(p.id)
            if category and p.category.lower() != category.lower():
                continue
            results.append({
                "id": p.id,
                "name": p.name,
                "price": float(p.price),
                "category": p.category,
                "stock": stock
            })
        return results

    # add product to customer cart after validation
    def add_item(self, customer_id: int, product_id: int, qty: int) -> Dict:
        if qty <= 0:
            return {"success": False, "message": "Quantity must be positive"}

        product = Product.find_by_id(product_id)
        if not product:
            return {"success": False, "message": "Product not found"}

        available = self.inventory.check_stock(product_id)
        if available < qty:
            return {"success": False, "message": f"Only {available} units available"}

        if qty > 50:
            return {"success": False, "message": "Cannot add more than 50 items"}

        cart = Cart.get_or_create_for_customer(customer_id)
        try:
            cart.add_item(product_id, qty)
            return {"success": True, "message": f"Added {qty}x {product.name} to cart"}
        except Exception as e:
            return {"success": False, "message": str(e)}

    # get current customer cart
    def get_cart(self, customer_id: int) -> Dict:
        cart = Cart.get_or_create_for_customer(customer_id)
        if not cart.items:
            return {"items": [], "total": 0.0}

        formatted_items = []
        for item in cart.items:
            formatted_items.append({
                "product_id": item["product_id"],
                "name": item["name"],
                "price": float(item["price"]),
                "qty": int(item["qty"]),
                "subtotal": float(item["subtotal"])
            })
        return {"items": formatted_items, "total": cart.total()}

    # update quantity of product in cart
    def update_item_quantity(self, customer_id: int, product_id: int, new_qty: int) -> Dict:
        cart = Cart.get_or_create_for_customer(customer_id)
        try:
            cart.update_quantity(product_id, new_qty)
            return {"success": True, "message": "Cart updated"}
        except Exception as e:
            return {"success": False, "message": str(e)}

    # remove product from cart
    def remove_item(self, customer_id: int, product_id: int) -> Dict:
        return self.update_item_quantity(customer_id, product_id, 0)

    # clear all items from cart
    def clear_cart(self, customer_id: int) -> Dict:
        cart = Cart.get_or_create_for_customer(customer_id)
        cart.clear()
        return {"success": True, "message": "Cart cleared"}


# ==== .\business\services\order_service.py ====
"""
File: order_service.py
Layer: Business Logic
Component: Order Service
Description:
    Handles checkout, order creation, invoice, payment, and shipment logic.
    Applies Factory Method for payment and updates Inventory/Cart.
"""
from typing import Dict
from business.models.cart import Cart
from business.models.order import Order
from business.models.invoice import Invoice
from business.models.payment import PaymentFactory
from business.models.inventory import Inventory
from business.models.shipment import Shipment
from business.exceptions.errors import InsufficientStockError, CartEmptyError
from storage.storage_manager import StorageManager


class OrderService:
    def __init__(self):
        # init inventory singleton
        self.inventory = Inventory.get_instance()

    # create order from cart and process payment
    def create_order(self, customer_id: int, payment_method: str = "card") -> Dict:
        cart = Cart.get_or_create_for_customer(customer_id)
        if not cart.items:
            raise CartEmptyError("Cannot checkout with empty cart")

        total = cart.total()

        # reserve stock before creating order
        try:
            cart.reserve_all()
        except InsufficientStockError as e:
            return {"success": False, "message": str(e)}
        except Exception as e:
            try:
                cart.release_all()
            except Exception:
                pass
            return {"success": False, "message": f"Stock reservation failed: {str(e)}"}

        # snapshot cart items for order
        order_items = []
        for item in cart.items:
            order_items.append({
                "product_id": item["product_id"],
                "name": item["name"],
                "quantity": item.get("qty", 0),
                "price": float(item.get("price", 0)),
                "subtotal": float(item.get("subtotal", 0)),
            })

        # create order and invoice
        order = Order.create(customer_id, order_items, total)
        invoice = Invoice.create(order.id, total)

        # process payment
        try:
            payment = PaymentFactory.create(payment_method, total, order.id)
            payment_message = payment.process()
        except Exception as e:
            cart.release_all()
            return {"success": False, "message": f"Payment failed: {str(e)}"}

        # mark invoice and order as paid
        invoice.mark_paid()
        order.mark_paid()

        # clear cart after success
        cart.clear()

        return {
            "success": True,
            "order_id": order.id,
            "total": total,
            "invoice_id": invoice.id,
            "payment_method": payment_method,
            "message": payment_message,
        }

    # mark order as shipped and record shipment
    def ship_order(self, order_id: int, tracking_number: str) -> Dict:
        order = Order.find_by_id(order_id)
        if not order:
            return {"success": False, "message": "Order not found"}
        if order.status != "PAID":
            return {"success": False, "message": "Order not yet paid"}

        shipment = Shipment.create(order_id, tracking_number)
        shipment.mark_shipped()
        order.mark_shipped()
        return {
            "success": True,
            "message": f"Order {order_id} shipped with tracking {tracking_number}"
        }

    # fetch detailed invoice and payment info
    def get_invoice_details(self, order_id: int) -> Dict:
        storage = StorageManager()
        order_data = storage.find_by_id("orders", order_id)
        if not order_data:
            return {"success": False, "message": f"Order {order_id} not found"}

        invoices = storage.load("invoices")
        payments = storage.load("payments")

        invoice = next((i for i in invoices if i["order_id"] == order_id), None)
        if not invoice:
            return {"success": False, "message": f"No invoice found for order {order_id}"}

        payment = next((p for p in payments if p["order_id"] == order_id), None)
        payment_method = payment["method"].title() if payment else "Unknown"

        # build item list for invoice view
        items = []
        for item in order_data.get("items", []):
            product_name = item.get("name", f"Product {item.get('product_id', '?')}")
            quantity = item.get("quantity", item.get("qty", 0))
            price = float(item.get("price", 0))
            subtotal = float(item.get("subtotal", quantity * price))
            items.append({
                "product": product_name,
                "quantity": quantity,
                "price": price,
                "subtotal": subtotal
            })

        return {
            "success": True,
            "order_id": order_data["id"],
            "invoice_id": invoice["id"],
            "payment_method": payment_method,
            "total": invoice["total"],
            "paid": invoice["paid"],
            "items": items,
        }


# ==== .\business\services\report_service.py ====
"""
File: report_service.py
Layer: Business Logic
Component: Report Service
Description:
    Generates sales and order analytics using Strategy Pattern.
"""
from typing import List, Dict
from business.models.report import (
    Report,
    DailyReportStrategy,
    MonthlyReportStrategy,
    AllTimeReportStrategy,
)

class ReportService:
    # generate report based on given period
    def generate(self, period: str) -> List[Dict]:
        p = period.lower()
        if p == "daily":
            strategy = DailyReportStrategy()
        elif p == "monthly":
            strategy = MonthlyReportStrategy()
        else:
            strategy = AllTimeReportStrategy()

        report = Report(strategy)
        return report.generate_report()


# ==== .\business\services\staff_service.py ====
"""
File: staff_service.py
Layer: Business Logic
Component: Staff Service
Description:
    Provides staff-level operations:
      - Viewing and fulfilling orders
      - Adjusting inventory levels
"""
from typing import Dict, List
from business.models.inventory import Inventory
from storage.storage_manager import StorageManager


class StaffService:
    def __init__(self):
        # init storage and inventory
        self.storage = StorageManager()
        self.inventory = Inventory.get_instance()

    # list all unshipped orders
    def view_pending_orders(self) -> List[Dict]:
        return [o for o in self.storage.load("orders") if o["status"] != "SHIPPED"]

    # set product stock directly
    def update_stock(self, product_id: int, new_qty: int) -> Dict:
        """
        Updates stock for a given product without direct printing
        (prevents duplicate console output).
        """
        try:
            self.inventory.set_stock(product_id, new_qty)
            # Return only â€” no console printing here
            return {"success": True, "message": f"Stock for product {product_id} set to {new_qty}"}
        except Exception as e:
            return {"success": False, "message": f"Error updating stock: {str(e)}"}

    # mark order as shipped and record shipment
    def ship_order(self, order_id: int, tracking_number: str) -> Dict:
        order = self.storage.find_by_id("orders", order_id)
        if not order:
            return {"success": False, "message": f"Order {order_id} not found"}
        if order.get("status") != "PAID":
            return {"success": False, "message": "Order not yet paid"}

        shipment = {"order_id": order_id, "tracking_number": tracking_number, "status": "SHIPPED"}
        self.storage.add("shipments", shipment)
        self.storage.update("orders", order_id, {"status": "SHIPPED"})

        return {"success": True, "message": f"Order {order_id} shipped with tracking {tracking_number}"}


# ==== .\business\services\__init__.py ====


# ==== .\data\accounts.json ====
[
  {
    "username": "customer1",
    "password": "Password123!",
    "user_type": "customer",
    "customer_id": 1,
    "staff_id": null,
    "id": 1
  },
  {
    "username": "staff1",
    "password": "Admin123!",
    "user_type": "staff",
    "customer_id": null,
    "staff_id": 1,
    "id": 2
  }
]

# ==== .\data\carts.json ====
[
  {
    "customer_id": 1,
    "items": [],
    "id": 1
  }
]

# ==== .\data\customers.json ====
[
  {
    "name": "John Doe",
    "email": "john@example.com",
    "address": "123 Main St, Melbourne",
    "id": 1
  }
]

# ==== .\data\inventory.json ====
[
  {
    "product_id": 1,
    "quantity": 75
  },
  {
    "product_id": 2,
    "quantity": 45
  },
  {
    "product_id": 3,
    "quantity": 25
  }
]

# ==== .\data\invoices.json ====
[
  {
    "order_id": 1,
    "total": 26.400000000000002,
    "paid": true,
    "id": 1
  },
  {
    "order_id": 2,
    "total": 26.400000000000002,
    "paid": true,
    "id": 2
  }
]

# ==== .\data\orders.json ====
[
  {
    "customer_id": 1,
    "items": [
      {
        "product_id": 1,
        "name": "Milk 1L",
        "quantity": 2,
        "price": 3.5,
        "subtotal": 7.0
      },
      {
        "product_id": 2,
        "name": "Bread Loaf",
        "quantity": 3,
        "price": 4.2,
        "subtotal": 12.600000000000001
      },
      {
        "product_id": 3,
        "name": "Eggs (12)",
        "quantity": 1,
        "price": 6.8,
        "subtotal": 6.8
      }
    ],
    "total": 26.400000000000002,
    "status": "SHIPPED",
    "created_at": "2025-11-04T17:24:18.115070",
    "id": 1
  },
  {
    "customer_id": 1,
    "items": [
      {
        "product_id": 1,
        "name": "Milk 1L",
        "quantity": 2,
        "price": 3.5,
        "subtotal": 7.0
      },
      {
        "product_id": 2,
        "name": "Bread Loaf",
        "quantity": 3,
        "price": 4.2,
        "subtotal": 12.600000000000001
      },
      {
        "product_id": 3,
        "name": "Eggs (12)",
        "quantity": 1,
        "price": 6.8,
        "subtotal": 6.8
      }
    ],
    "total": 26.400000000000002,
    "status": "SHIPPED",
    "created_at": "2025-11-05T14:48:06.532043",
    "id": 2
  }
]

# ==== .\data\payments.json ====
[
  {
    "order_id": 1,
    "method": "card",
    "amount": 26.400000000000002,
    "status": "APPROVED",
    "id": 1
  },
  {
    "order_id": 2,
    "method": "wallet",
    "amount": 26.400000000000002,
    "status": "APPROVED",
    "id": 2
  }
]

# ==== .\data\products.json ====
[
  {
    "name": "Milk 1L",
    "description": "Fresh milk bottle",
    "price": 3.5,
    "category": "Dairy",
    "id": 1
  },
  {
    "name": "Bread Loaf",
    "description": "Whole grain loaf",
    "price": 4.2,
    "category": "Bakery",
    "id": 2
  },
  {
    "name": "Eggs (12)",
    "description": "Dozen free-range eggs",
    "price": 6.8,
    "category": "Dairy",
    "id": 3
  }
]

# ==== .\data\shipments.json ====
[
  {
    "order_id": 1,
    "tracking_number": "TRACK123",
    "status": "SHIPPED",
    "id": 1
  },
  {
    "order_id": 2,
    "tracking_number": "TRACK123",
    "status": "SHIPPED",
    "id": 2
  }
]

# ==== .\data\staff.json ====
[
  {
    "username": "staff1",
    "name": "Admin User",
    "id": 1
  }
]

# ==== .\presentation\cli_controller.py ====
"""
File: cli_controller.py
Layer: Presentation
Description:
    Routes CLI commands to business services with error handling and user prompts.
"""
from typing import Dict, List
from rich.console import Console
from presentation.formatters import (
    display_products_table,
    display_cart_table,
    display_report_table,
    display_orders_table,
    display_invoice_table,
)
from business.services.auth_service import AuthService
from business.services.cart_service import CartService
from business.services.order_service import OrderService
from business.services.report_service import ReportService
from business.services.staff_service import StaffService
from business.exceptions.errors import InsufficientStockError, CartEmptyError

console = Console()


class CLIController:
    def __init__(self):
        self.auth_service = AuthService()
        self.cart_service = CartService()
        self.order_service = OrderService()
        self.report_service = ReportService()
        self.staff_service = StaffService()

    # ---------------------- SYSTEM SETUP ---------------------- #
    def initialize_system(self) -> Dict:
        try:
            result = self.auth_service.initialize_system()
            return result
        except Exception as e:
            return {"success": False, "message": f"Initialization failed: {str(e)}"}

    # ---------------------- AUTH ------------------------------ #
    def login(self, username: str, password: str) -> Dict:
        return self.auth_service.login(username, password)

    def logout(self) -> Dict:
        return self.auth_service.logout()

    # ---------------------- CUSTOMER / GENERAL OPS ---------------------- #
    def browse_products(self, category: str = None) -> List[Dict]:
        """Allow any logged-in user (staff or customer) to browse."""
        user = self.auth_service.get_current_user()
        if not user:
            console.print("[red]Please login first.[/red]")
            return []

        try:
            products = self.cart_service.browse_products(category)
            if not products:
                console.print("[yellow]No products found.[/yellow]")
            return products
        except Exception as e:
            console.print(f"[red]Failed to load products: {str(e)}[/red]")
            return []

    def add_to_cart(self, product_id: int, quantity: int) -> Dict:
        """Only customers can add items to cart."""
        user = self.auth_service.get_current_user()
        if not user:
            return {"success": False, "message": "Please login first"}
        if user.get("user_type") != "customer":
            return {"success": False, "message": "Customer access required"}
        return self.cart_service.add_item(user["customer_id"], product_id, quantity)

    def view_cart(self) -> Dict:
        """Only customers can view their cart."""
        user = self.auth_service.get_current_user()
        if not user:
            console.print("[red]Please login first.[/red]")
            return {"items": [], "total": 0.0}
        if user.get("user_type") != "customer":
            console.print("[red]Customer access required.[/red]")
            return {"items": [], "total": 0.0}

        cart = self.cart_service.get_cart(user["customer_id"])
        if not cart.get("items"):
            console.print("[yellow]Your cart is empty.[/yellow]")
        return cart

    def checkout(self) -> Dict:
        """Checkout cart for logged-in customer."""
        user = self.auth_service.get_current_user()
        if not user or user.get("user_type") != "customer":
            return {"success": False, "message": "Please login first"}

        cart = self.cart_service.get_cart(user["customer_id"])
        if not cart.get("items"):
            console.print("[yellow]Cart is empty. Please add items before checkout.[/yellow]")
            return {"success": False, "message": "Cart is empty"}

        try:
            console.print("\n[bold yellow]Select Payment Method:[/bold yellow]")
            console.print("1. Card\n2. Wallet")
            choice = input("Enter choice (1 or 2): ").strip()
            method = "card" if choice == "1" else "wallet"

            result = self.order_service.create_order(user["customer_id"], payment_method=method)

            if result.get("success"):
                console.print(f"\n[bold green]Payment Successful via {method.title()}[/bold green]")
                console.print(f"Invoice ID: {result.get('invoice_id')}")
                console.print(f"Order ID: {result.get('order_id')}")
                console.print("\n[cyan]Use this command to view your invoice:[/cyan]")
                console.print(f"[bold yellow]python main.py view-invoice {result.get('order_id')}[/bold yellow]")
            else:
                console.print(f"[red]Checkout failed:[/red] {result.get('message')}")
            return result

        except CartEmptyError as e:
            console.print(f"[yellow]{str(e)}[/yellow]")
            return {"success": False, "message": str(e)}
        except InsufficientStockError as e:
            console.print(f"[red]{str(e)}[/red]")
            return {"success": False, "message": str(e)}
        except Exception as e:
            console.print(f"[red]Checkout failed: {str(e)}[/red]")
            return {"success": False, "message": f"Checkout failed: {str(e)}"}

    def view_invoice(self, order_id: int) -> Dict:
        """View invoice for logged-in customer."""
        user = self.auth_service.get_current_user()
        if not user or user.get("user_type") != "customer":
            console.print("[red]Please login first.[/red]")
            return {}
        result = self.order_service.get_invoice_details(order_id)
        display_invoice_table(result)
        return result

    # ---------------------- STAFF OPS ------------------------- #
    def ship_order(self, order_id: int, tracking_number: str) -> Dict:
        user = self.auth_service.get_current_user()
        if not user or user.get("user_type") != "staff":
            return {"success": False, "message": "Staff access required"}
        return self.staff_service.ship_order(order_id, tracking_number)

    def generate_report(self, period: str) -> List[Dict]:
        user = self.auth_service.get_current_user()
        if not user:
            console.print("[red]Please login first.[/red]")
            return []
        if user.get("user_type") != "staff":
            console.print("[red]Staff access required.[/red]")
            return []
        return self.report_service.generate(period)

    def view_pending_orders(self) -> List[Dict]:
        user = self.auth_service.get_current_user()
        if not user:
            console.print("[red]Please login first.[/red]")
            return []
        if user.get("user_type") != "staff":
            console.print("[red]Staff access required.[/red]")
            return []
        orders = self.staff_service.view_pending_orders()
        if not orders:
            console.print("[yellow]No pending orders found.[/yellow]")
        return orders

    def update_stock(self, product_id: int, new_quantity: int) -> Dict:
        user = self.auth_service.get_current_user()
        if not user:
            return {"success": False, "message": "Please login first"}
        if user.get("user_type") != "staff":
            return {"success": False, "message": "Staff access required"}
        return self.staff_service.update_stock(product_id, new_quantity)

    # ---------------------- DISPLAY HELPERS ------------------- #
    def display_products(self, products: List[Dict]):
        display_products_table(products)

    def display_cart(self, cart_data: Dict):
        display_cart_table(cart_data)

    def display_report(self, report_data: List[Dict]):
        display_report_table(report_data)

    def display_orders(self, orders: List[Dict]):
        display_orders_table(orders)


# ==== .\presentation\formatters.py ====
"""
File: formatters.py
Layer: Presentation
Description:
    Handles terminal output formatting for product listings, carts, invoices, and reports.
"""
from rich.table import Table
from rich.console import Console

console = Console()

# show list of products
def display_products_table(products):
    if not products:
        console.print("[yellow]No products found[/yellow]")
        return

    table = Table(title="Product Catalogue")
    table.add_column("ID", justify="right", style="cyan")
    table.add_column("Name", style="magenta")
    table.add_column("Category", style="blue")
    table.add_column("Price", style="green")
    table.add_column("Stock", style="yellow")

    for p in products:
        stock_display = str(p["stock"]) if p["stock"] > 0 else "[red]Out of Stock[/red]"
        table.add_row(str(p["id"]), p["name"], p["category"], f"${p['price']:.2f}", stock_display)

    console.print(table)

# show cart items
def display_cart_table(cart):
    items = cart.get("items", [])
    if not items:
        console.print("[yellow]Cart is empty[/yellow]")
        return

    table = Table(title="Your Shopping Cart")
    table.add_column("Product", style="cyan")
    table.add_column("Qty", justify="right", style="yellow")
    table.add_column("Price", justify="right", style="green")
    table.add_column("Subtotal", justify="right", style="magenta")

    for item in items:
        table.add_row(item["name"], str(item["qty"]), f"${item['price']:.2f}", f"${item['subtotal']:.2f}")

    console.print(table)
    console.print(f"\n[bold green]Total: ${cart.get('total', 0.0):.2f}[/bold green]")

# show invoice details
def display_invoice_table(invoice):
    if not invoice.get("success"):
        console.print(f"[red]âœ— {invoice.get('message', 'Invoice not found')}[/red]")
        return

    console.print("\n[bold cyan]Invoice Summary[/bold cyan]")
    console.print(
        f"[dim]Order ID:[/dim] {invoice['order_id']}   "
        f"[dim]Invoice ID:[/dim] {invoice['invoice_id']}   "
        f"[dim]Method:[/dim] {invoice['payment_method']}"
    )
    console.print(
        f"[dim]Status:[/dim] "
        f"{'[green]Paid[/green]' if invoice['paid'] else '[red]Unpaid[/red]'}   "
        f"[dim]Total:[/dim] [bold cyan]${invoice['total']:.2f}[/bold cyan]\n"
    )

    table = Table(title="Invoice Details")
    table.add_column("Product", style="cyan")
    table.add_column("Qty", justify="right", style="yellow")
    table.add_column("Price", justify="right", style="green")
    table.add_column("Subtotal", justify="right", style="magenta")

    for item in invoice["items"]:
        subtotal = item["quantity"] * item["price"]
        table.add_row(item["product"], str(item["quantity"]), f"${item['price']:.2f}", f"${subtotal:.2f}")

    console.print(table)
    console.print("\n")

# show report summary
def display_report_table(report):
    if not report:
        console.print("[yellow]No report data available[/yellow]")
        return

    table = Table(title="Report Summary")
    table.add_column("Metric", style="cyan")
    table.add_column("Value", justify="right", style="green")

    for r in report:
        table.add_row(r["metric"], str(r["value"]))

    console.print(table)


def display_orders_table(orders: list):
    if not orders:
        console.print("[yellow]No orders found.[/yellow]")
        return

    for order in orders:
        table = Table(title=f"Order ID: {order['id']} | Status: {order['status']} | Total: ${order['total']:.2f}")

        table.add_column("Product ID", justify="right")
        table.add_column("Name")
        table.add_column("Qty", justify="right")
        table.add_column("Price", justify="right")
        table.add_column("Subtotal", justify="right")

        for item in order.get("items", []):
            table.add_row(
                str(item["product_id"]),
                item["name"],
                str(item["quantity"]),
                f"${item['price']:.2f}",
                f"${item['subtotal']:.2f}"
            )

        console.print(table)
        console.print()  # blank line between orders


# ==== .\presentation\__init__.py ====


# ==== .\storage\json_handler.py ====
"""
File: json_handler.py
Layer: Data Access
Component: JSON Handler
Description:
    Provides low-level JSON file operations:
      - Safe read and write
      - Automatic file creation
      - Atomic write with Windows-safe rename fallback
"""
import json
import os
import shutil
import time
from pathlib import Path
from typing import Any, List, Dict

class JSONHandler:
    """Handles reading and writing JSON files safely."""

    # read JSON file, return list or empty if missing/invalid
    @staticmethod
    def read_json(file_path: Path) -> List[Dict[str, Any]]:
        if not file_path.exists():
            file_path.write_text("[]")
            return []
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except (json.JSONDecodeError, FileNotFoundError):
            return []

    # write JSON data atomically with Windows-safe fallback
    @staticmethod
    def write_json(file_path: Path, data: List[Dict[str, Any]]) -> None:
        tmp_path = file_path.with_suffix(".tmp")

        # write to temp file
        with open(tmp_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)

        # replace file atomically or retry if locked
        try:
            os.replace(tmp_path, file_path)
        except PermissionError:
            for _ in range(3):
                time.sleep(0.1)
                try:
                    os.replace(tmp_path, file_path)
                    return
                except PermissionError:
                    continue
            # final fallback if file still locked
            try:
                os.remove(file_path)
            except FileNotFoundError:
                pass
            shutil.move(tmp_path, file_path)


# ==== .\storage\session_manager.py ====
"""
File: session_manager.py
Layer: Storage
Component: Session Manager
Description:
    Manages user session state across CLI commands using file-based storage.
    Each command reads the current session to maintain login state.
"""
import json
from pathlib import Path
from typing import Optional, Dict
from app_config import DATA_DIR

SESSION_FILE = DATA_DIR / "session.json"

class SessionManager:
    """Handles persistent session state for CLI."""

    # save current user session to file
    @staticmethod
    def save_session(user_data: Dict) -> None:
        with open(SESSION_FILE, 'w') as f:
            json.dump(user_data, f, indent=2)

    # load existing session from file
    @staticmethod
    def load_session() -> Optional[Dict]:
        if not SESSION_FILE.exists():
            return None
        try:
            with open(SESSION_FILE, 'r') as f:
                data = json.load(f)
                return data if data else None
        except (json.JSONDecodeError, FileNotFoundError):
            return None

    # remove session file to clear login state
    @staticmethod
    def clear_session() -> None:
        if SESSION_FILE.exists():
            SESSION_FILE.unlink()


# ==== .\storage\storage_manager.py ====
"""
File: storage_manager.py
Layer: Data Access
Component: Storage Manager
Description:
    Unified interface for file-based persistence.
    Responsibilities:
      - Map entity types to JSON files
      - Provide CRUD operations
      - Ensure data files exist
      - Maintain ID auto-incrementing
Collaborators:
      - JSONHandler (low-level I/O)
      - app_config (file paths)
"""

from typing import List, Dict, Any, Optional
from app_config import (
    CUSTOMERS_FILE, ACCOUNTS_FILE, PRODUCTS_FILE, INVENTORY_FILE,
    ORDERS_FILE, INVOICES_FILE, PAYMENTS_FILE, SHIPMENTS_FILE,
    CARTS_FILE, STAFF_FILE
)
from storage.json_handler import JSONHandler


class StorageManager:
    """High-level persistence API used by business services."""

    _file_map = {
        "customers": CUSTOMERS_FILE,
        "accounts": ACCOUNTS_FILE,
        "products": PRODUCTS_FILE,
        "inventory": INVENTORY_FILE,
        "orders": ORDERS_FILE,
        "invoices": INVOICES_FILE,
        "payments": PAYMENTS_FILE,
        "shipments": SHIPMENTS_FILE,
        "carts": CARTS_FILE,
        "staff": STAFF_FILE,
    }

    def __init__(self):
        # setup JSON handler and ensure all files exist
        self.json_handler = JSONHandler()
        self.ensure_files()

    # create empty files if missing
    def ensure_files(self) -> None:
        for path in self._file_map.values():
            if not path.exists():
                self.json_handler.write_json(path, [])

    # load all records for entity
    def load(self, entity: str) -> List[Dict[str, Any]]:
        file_path = self._file_map.get(entity)
        if not file_path:
            raise ValueError(f"Unknown entity type: {entity}")
        return self.json_handler.read_json(file_path)

    # alias for backward compatibility
    def get_all(self, entity: str) -> List[Dict[str, Any]]:
        return self.load(entity)

    # keep read() alias for older code
    read = get_all

    # save all records back to file
    def save_all(self, entity: str, data: List[Dict[str, Any]]) -> None:
        file_path = self._file_map.get(entity)
        try:
            self.json_handler.write_json(file_path, data)
        except Exception as e:
            print(f"[ERROR] Failed to save {entity}: {e}")

    # add record with auto-incremented ID
    def add(self, entity: str, record: Dict[str, Any]) -> Dict[str, Any]:
        records = self.load(entity)
        max_id = max((r.get("id", 0) for r in records), default=0)
        record["id"] = max_id + 1
        records.append(record)
        self.save_all(entity, records)
        return record

    # update record by ID
    def update(self, entity: str, record_id: int, updates: Dict[str, Any]) -> bool:
        records = self.load(entity)
        for rec in records:
            if rec.get("id") == record_id:
                rec.update(updates)
                self.save_all(entity, records)
                return True
        return False

    # delete record by ID
    def delete(self, entity: str, record_id: int) -> bool:
        records = self.load(entity)
        new_records = [r for r in records if r.get("id") != record_id]
        if len(new_records) != len(records):
            self.save_all(entity, new_records)
            return True
        return False

    # find single record by ID
    def find_by_id(self, entity: str, record_id: int) -> Optional[Dict[str, Any]]:
        for rec in self.load(entity):
            if rec.get("id") == record_id:
                return rec
        return None


# ==== .\storage\__init__.py ====


# ==== .\tests\test_complete_system.py ====
"""
===============================================================================
File: tests/test_complete_system.py
Description:
    Comprehensive integration tests for OCSS.
    Tests all major workflows: authentication, cart, checkout, staff ops.
    
Run with: pytest tests/test_complete_system.py -v
===============================================================================
"""

import pytest
import json
from pathlib import Path
import sys

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from business.models.customer import Customer
from business.models.product import Product
from business.models.inventory import Inventory
from business.models.cart import Cart
from business.models.order import Order
from business.models.account import Account
from business.services.auth_service import AuthService
from business.services.cart_service import CartService
from business.services.order_service import OrderService
from business.services.report_service import ReportService
from storage.storage_manager import StorageManager
from business.exceptions.errors import InsufficientStockError, CartEmptyError


@pytest.fixture(scope="function")
def clean_data_files():
    """Remove all JSON files before each test for clean state"""
    data_dir = Path("data")
    if data_dir.exists():
        for json_file in data_dir.glob("*.json"):
            json_file.unlink()
    yield
    # Cleanup after test
    for json_file in data_dir.glob("*.json"):
        json_file.unlink()


@pytest.fixture
def auth_service(clean_data_files):
    """Initialize auth service with sample data"""
    service = AuthService()
    service.initialize_system()
    return service


@pytest.fixture
def cart_service(auth_service):
    """Cart service fixture"""
    return CartService()


@pytest.fixture
def order_service(auth_service):
    """Order service fixture"""
    return OrderService()


# ============================================================================
# TEST GROUP 1: AUTHENTICATION & SESSION MANAGEMENT
# ============================================================================

def test_customer_login_success(auth_service):
    """Test successful customer login"""
    result = auth_service.login("customer1", "Password123!")
    assert result["success"] == True
    assert result["user"]["user_type"] == "customer"
    assert result["user"]["username"] == "customer1"


def test_staff_login_success(auth_service):
    """Test successful staff login"""
    result = auth_service.login("staff1", "Admin123!")
    assert result["success"] == True
    assert result["user"]["user_type"] == "staff"


def test_login_invalid_credentials(auth_service):
    """Test login with wrong credentials"""
    result = auth_service.login("wronguser", "wrongpass")
    assert result["success"] == False
    assert "Invalid credentials" in result["message"]


def test_logout(auth_service):
    """Test logout clears session"""
    auth_service.login("customer1", "Password123!")
    result = auth_service.logout()
    assert result["success"] == True
    assert auth_service.get_current_user() is None


# ============================================================================
# TEST GROUP 2: PRODUCT & INVENTORY
# ============================================================================

def test_browse_all_products(cart_service):
    """Test browsing all products"""
    products = cart_service.browse_products()
    assert len(products) == 3
    assert products[0]["name"] == "Milk 1L"
    assert products[0]["stock"] == 50


def test_browse_by_category(cart_service):
    """Test filtering products by category"""
    products = cart_service.browse_products(category="Dairy")
    assert len(products) == 2  # Milk and Eggs
    assert all(p["category"] == "Dairy" for p in products)


def test_inventory_singleton(auth_service):
    """Test Inventory Singleton pattern"""
    inv1 = Inventory.get_instance()
    inv2 = Inventory.get_instance()
    assert inv1 is inv2  # Same instance


def test_inventory_stock_check(auth_service):
    """Test checking stock levels"""
    inv = Inventory.get_instance()
    stock = inv.check_stock(1)  # Milk
    assert stock == 50


def test_inventory_reserve_stock(auth_service):
    """Test reserving stock"""
    inv = Inventory.get_instance()
    initial = inv.check_stock(1)
    inv.reserve_stock(1, 5)
    assert inv.check_stock(1) == initial - 5


def test_inventory_insufficient_stock(auth_service):
    """Test error when insufficient stock"""
    inv = Inventory.get_instance()
    with pytest.raises(InsufficientStockError):
        inv.reserve_stock(1, 9999)


# ============================================================================
# TEST GROUP 3: CART OPERATIONS
# ============================================================================

def test_add_item_to_cart(auth_service, cart_service):
    """Test adding item to cart"""
    result = cart_service.add_item(customer_id=1, product_id=1, qty=2)
    assert result["success"] == True
    assert "Added 2x Milk 1L" in result["message"]


def test_add_invalid_product(auth_service, cart_service):
    """Test adding non-existent product"""
    result = cart_service.add_item(customer_id=1, product_id=999, qty=1)
    assert result["success"] == False
    assert "Product not found" in result["message"]


def test_add_insufficient_stock(auth_service, cart_service):
    """Test adding more than available stock"""
    result = cart_service.add_item(customer_id=1, product_id=1, qty=9999)
    assert result["success"] == False
    assert "available" in result["message"].lower()


def test_view_cart(auth_service, cart_service):
    """Test viewing cart contents"""
    cart_service.add_item(customer_id=1, product_id=1, qty=2)
    cart_service.add_item(customer_id=1, product_id=2, qty=3)
    
    cart_data = cart_service.get_cart(customer_id=1)
    assert len(cart_data["items"]) == 2
    assert cart_data["total"] == (2 * 3.5) + (3 * 4.2)  # Milk + Bread


def test_cart_quantity_update(auth_service, cart_service):
    """Test updating item quantity in cart"""
    cart_service.add_item(customer_id=1, product_id=1, qty=2)
    cart_service.add_item(customer_id=1, product_id=1, qty=3)  # Add more
    
    cart_data = cart_service.get_cart(customer_id=1)
    milk_item = next(i for i in cart_data["items"] if i["product_id"] == 1)
    assert milk_item["qty"] == 5  # Should be 2 + 3


def test_view_empty_cart(auth_service, cart_service):
    """Test viewing empty cart"""
    cart_data = cart_service.get_cart(customer_id=1)
    assert cart_data["items"] == []
    assert cart_data["total"] == 0.0


# ============================================================================
# TEST GROUP 4: CHECKOUT & ORDER CREATION
# ============================================================================

def test_checkout_success(auth_service, cart_service, order_service):
    """Test successful checkout"""
    # Add items to cart
    cart_service.add_item(customer_id=1, product_id=1, qty=2)
    
    # Checkout
    result = order_service.create_order(customer_id=1)
    
    assert result["success"] == True
    assert result["order_id"] == 1
    assert result["total"] == 7.0  # 2 * 3.5


def test_checkout_empty_cart(auth_service, order_service):
    """Test checkout with empty cart"""
    with pytest.raises(CartEmptyError):
        order_service.create_order(customer_id=1)


def test_checkout_reduces_inventory(auth_service, cart_service, order_service):
    """Test that checkout reduces stock"""
    inv = Inventory.get_instance()
    initial_stock = inv.check_stock(1)
    
    # Add to cart and checkout
    cart_service.add_item(customer_id=1, product_id=1, qty=2)
    order_service.create_order(customer_id=1)
    
    # Verify stock reduced
    assert inv.check_stock(1) == initial_stock - 2


def test_checkout_clears_cart(auth_service, cart_service, order_service):
    """Test that checkout clears the cart"""
    cart_service.add_item(customer_id=1, product_id=1, qty=2)
    order_service.create_order(customer_id=1)
    
    cart_data = cart_service.get_cart(customer_id=1)
    assert cart_data["items"] == []


def test_checkout_creates_invoice(auth_service, cart_service, order_service):
    """Test that checkout creates invoice"""
    cart_service.add_item(customer_id=1, product_id=1, qty=2)
    result = order_service.create_order(customer_id=1)
    
    # Check invoice created
    storage = StorageManager()
    invoices = storage.load("invoices")
    assert len(invoices) == 1
    assert invoices[0]["order_id"] == result["order_id"]
    assert invoices[0]["paid"] == True


def test_checkout_creates_payment(auth_service, cart_service, order_service):
    """Test that checkout creates payment record (Factory Method pattern)"""
    cart_service.add_item(customer_id=1, product_id=1, qty=2)
    result = order_service.create_order(customer_id=1)
    
    # Check payment created
    storage = StorageManager()
    payments = storage.load("payments")
    assert len(payments) == 1
    assert payments[0]["order_id"] == result["order_id"]
    assert payments[0]["status"] == "APPROVED"


# ============================================================================
# TEST GROUP 5: STAFF OPERATIONS
# ============================================================================

def test_ship_order_success(auth_service, cart_service, order_service):
    """Test staff shipping an order"""
    # Create order first
    cart_service.add_item(customer_id=1, product_id=1, qty=2)
    order_result = order_service.create_order(customer_id=1)
    
    # Ship order
    ship_result = order_service.ship_order(order_result["order_id"], "TRACK123")
    assert ship_result["success"] == True


def test_ship_nonexistent_order(auth_service, order_service):
    """Test shipping non-existent order"""
    result = order_service.ship_order(999, "TRACK123")
    assert result["success"] == False
    assert "not found" in result["message"]


# ============================================================================
# TEST GROUP 6: REPORTING (Strategy Pattern)
# ============================================================================

def test_daily_report(auth_service, cart_service, order_service):
    """Test daily report generation (Strategy pattern)"""
    # Create an order
    cart_service.add_item(customer_id=1, product_id=1, qty=2)
    order_service.create_order(customer_id=1)
    
    # Generate daily report
    report_service = ReportService()
    report = report_service.generate("daily")
    
    assert len(report) > 0
    assert any(r["metric"] == "Report Type" and r["value"] == "Daily" for r in report)


def test_monthly_report(auth_service):
    """Test monthly report generation"""
    report_service = ReportService()
    report = report_service.generate("monthly")
    
    assert len(report) > 0
    assert any(r["metric"] == "Report Type" and r["value"] == "Monthly" for r in report)


def test_all_time_report(auth_service):
    """Test all-time report generation"""
    report_service = ReportService()
    report = report_service.generate("all")
    
    assert len(report) > 0
    assert any(r["metric"] == "Report Type" and r["value"] == "All-Time" for r in report)


# ============================================================================
# TEST GROUP 7: DOMAIN MODEL INTEGRITY
# ============================================================================

def test_customer_order_history(auth_service, cart_service, order_service):
    """Test customer can retrieve order history"""
    # Create multiple orders
    cart_service.add_item(customer_id=1, product_id=1, qty=1)
    order_service.create_order(customer_id=1)
    
    cart_service.add_item(customer_id=1, product_id=2, qty=1)
    order_service.create_order(customer_id=1)
    
    # Check order history
    customer = Customer.find_by_id(1)
    history = customer.order_history()
    assert len(history) == 2


def test_product_find_by_id(auth_service):
    """Test finding product by ID"""
    product = Product.find_by_id(1)
    assert product is not None
    assert product.name == "Milk 1L"
    assert product.price == 3.5


def test_order_persistence(auth_service, cart_service, order_service):
    """Test order data persists correctly"""
    cart_service.add_item(customer_id=1, product_id=1, qty=2)
    result = order_service.create_order(customer_id=1)
    
    # Retrieve order
    order = Order.find_by_id(result["order_id"])
    assert order is not None
    assert order.customer_id == 1
    assert order.total == 7.0
    assert order.status == "PAID"


# ============================================================================
# TEST GROUP 8: DESIGN PATTERNS VALIDATION
# ============================================================================

def test_singleton_pattern_inventory(auth_service):
    """Verify Singleton pattern for Inventory"""
    # Get multiple instances
    inv1 = Inventory.get_instance()
    inv2 = Inventory.get_instance()
    inv3 = Inventory()
    
    # All should be same instance
    assert inv1 is inv2
    assert inv2 is inv3


def test_factory_method_payment(auth_service, cart_service, order_service):
    """Verify Factory Method pattern creates correct payment type"""
    cart_service.add_item(customer_id=1, product_id=1, qty=1)
    order_service.create_order(customer_id=1)
    
    storage = StorageManager()
    payments = storage.load("payments")
    
    # Factory should create card payment by default
    assert payments[0]["method"] == "card"


def test_strategy_pattern_reports(auth_service):
    """Verify Strategy pattern allows different report types"""
    report_service = ReportService()
    
    daily = report_service.generate("daily")
    monthly = report_service.generate("monthly")
    all_time = report_service.generate("all")
    
    # Each strategy produces different report type
    assert daily[0]["value"] == "Daily"
    assert monthly[0]["value"] == "Monthly"
    assert all_time[0]["value"] == "All-Time"

def test_staff_update_stock(auth_service):
    service = auth_service
    from business.services.staff_service import StaffService
    staff_service = StaffService()
    result = staff_service.update_stock(1, 99)
    assert result["success"]


# ============================================================================
# RUN SUMMARY
# ============================================================================

if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])

# ==== .\tests\__init__.py ====


